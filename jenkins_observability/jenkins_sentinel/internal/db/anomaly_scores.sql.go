// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: anomaly_scores.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnomalyScore = `-- name: CreateAnomalyScore :one
INSERT INTO anomaly_scores (
    pipeline_name,
    build_number,
    metric_name,
    detector_name,
    timestamp,
    value,
    score,
    threshold,
    is_anomaly
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, pipeline_name, build_number, metric_name, detector_name, timestamp, value, score, threshold, is_anomaly, created_at
`

type CreateAnomalyScoreParams struct {
	PipelineName string             `json:"pipeline_name"`
	BuildNumber  pgtype.Int4        `json:"build_number"`
	MetricName   string             `json:"metric_name"`
	DetectorName string             `json:"detector_name"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
	Value        float64            `json:"value"`
	Score        float64            `json:"score"`
	Threshold    float64            `json:"threshold"`
	IsAnomaly    bool               `json:"is_anomaly"`
}

func (q *Queries) CreateAnomalyScore(ctx context.Context, arg CreateAnomalyScoreParams) (AnomalyScore, error) {
	row := q.db.QueryRow(ctx, createAnomalyScore,
		arg.PipelineName,
		arg.BuildNumber,
		arg.MetricName,
		arg.DetectorName,
		arg.Timestamp,
		arg.Value,
		arg.Score,
		arg.Threshold,
		arg.IsAnomaly,
	)
	var i AnomalyScore
	err := row.Scan(
		&i.ID,
		&i.PipelineName,
		&i.BuildNumber,
		&i.MetricName,
		&i.DetectorName,
		&i.Timestamp,
		&i.Value,
		&i.Score,
		&i.Threshold,
		&i.IsAnomaly,
		&i.CreatedAt,
	)
	return i, err
}

type CreateAnomalyScoresParams struct {
	PipelineName string             `json:"pipeline_name"`
	BuildNumber  pgtype.Int4        `json:"build_number"`
	MetricName   string             `json:"metric_name"`
	DetectorName string             `json:"detector_name"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
	Value        float64            `json:"value"`
	Score        float64            `json:"score"`
	Threshold    float64            `json:"threshold"`
	IsAnomaly    bool               `json:"is_anomaly"`
}

const deleteOldAnomalyScores = `-- name: DeleteOldAnomalyScores :exec
DELETE FROM anomaly_scores
WHERE timestamp < $1
`

func (q *Queries) DeleteOldAnomalyScores(ctx context.Context, timestamp pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldAnomalyScores, timestamp)
	return err
}

const getAnomaliesByMetric = `-- name: GetAnomaliesByMetric :many
SELECT id, pipeline_name, build_number, metric_name, detector_name, timestamp, value, score, threshold, is_anomaly, created_at
FROM anomaly_scores
WHERE metric_name = $1
    AND is_anomaly = true
    AND timestamp >= $2
    AND timestamp <= $3
ORDER BY score DESC, timestamp DESC
`

type GetAnomaliesByMetricParams struct {
	MetricName  string             `json:"metric_name"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

func (q *Queries) GetAnomaliesByMetric(ctx context.Context, arg GetAnomaliesByMetricParams) ([]AnomalyScore, error) {
	rows, err := q.db.Query(ctx, getAnomaliesByMetric, arg.MetricName, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnomalyScore
	for rows.Next() {
		var i AnomalyScore
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.MetricName,
			&i.DetectorName,
			&i.Timestamp,
			&i.Value,
			&i.Score,
			&i.Threshold,
			&i.IsAnomaly,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnomaliesByPipeline = `-- name: GetAnomaliesByPipeline :many
SELECT id, pipeline_name, build_number, metric_name, detector_name, timestamp, value, score, threshold, is_anomaly, created_at
FROM anomaly_scores
WHERE pipeline_name = $1
    AND timestamp >= $2
    AND timestamp <= $3
ORDER BY timestamp DESC
`

type GetAnomaliesByPipelineParams struct {
	PipelineName string             `json:"pipeline_name"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2  pgtype.Timestamptz `json:"timestamp_2"`
}

func (q *Queries) GetAnomaliesByPipeline(ctx context.Context, arg GetAnomaliesByPipelineParams) ([]AnomalyScore, error) {
	rows, err := q.db.Query(ctx, getAnomaliesByPipeline, arg.PipelineName, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnomalyScore
	for rows.Next() {
		var i AnomalyScore
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.MetricName,
			&i.DetectorName,
			&i.Timestamp,
			&i.Value,
			&i.Score,
			&i.Threshold,
			&i.IsAnomaly,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnomalyCountByPipeline = `-- name: GetAnomalyCountByPipeline :many
SELECT 
    pipeline_name,
    metric_name,
    COUNT(*) FILTER (WHERE is_anomaly = true) as anomaly_count,
    COUNT(*) as total_scores,
    AVG(score) as avg_score,
    MAX(score) as max_score
FROM anomaly_scores
WHERE timestamp >= $1
    AND timestamp <= $2
GROUP BY pipeline_name, metric_name
ORDER BY anomaly_count DESC
`

type GetAnomalyCountByPipelineParams struct {
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

type GetAnomalyCountByPipelineRow struct {
	PipelineName string      `json:"pipeline_name"`
	MetricName   string      `json:"metric_name"`
	AnomalyCount int64       `json:"anomaly_count"`
	TotalScores  int64       `json:"total_scores"`
	AvgScore     float64     `json:"avg_score"`
	MaxScore     interface{} `json:"max_score"`
}

func (q *Queries) GetAnomalyCountByPipeline(ctx context.Context, arg GetAnomalyCountByPipelineParams) ([]GetAnomalyCountByPipelineRow, error) {
	rows, err := q.db.Query(ctx, getAnomalyCountByPipeline, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAnomalyCountByPipelineRow
	for rows.Next() {
		var i GetAnomalyCountByPipelineRow
		if err := rows.Scan(
			&i.PipelineName,
			&i.MetricName,
			&i.AnomalyCount,
			&i.TotalScores,
			&i.AvgScore,
			&i.MaxScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnomalyScoresByDetector = `-- name: GetAnomalyScoresByDetector :many
SELECT id, pipeline_name, build_number, metric_name, detector_name, timestamp, value, score, threshold, is_anomaly, created_at
FROM anomaly_scores
WHERE detector_name = $1
    AND timestamp >= $2
    AND timestamp <= $3
ORDER BY timestamp DESC
`

type GetAnomalyScoresByDetectorParams struct {
	DetectorName string             `json:"detector_name"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2  pgtype.Timestamptz `json:"timestamp_2"`
}

func (q *Queries) GetAnomalyScoresByDetector(ctx context.Context, arg GetAnomalyScoresByDetectorParams) ([]AnomalyScore, error) {
	rows, err := q.db.Query(ctx, getAnomalyScoresByDetector, arg.DetectorName, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnomalyScore
	for rows.Next() {
		var i AnomalyScore
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.MetricName,
			&i.DetectorName,
			&i.Timestamp,
			&i.Value,
			&i.Score,
			&i.Threshold,
			&i.IsAnomaly,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildDataForAnomaly = `-- name: GetBuildDataForAnomaly :many
SELECT 
    a.id,
    a.pipeline_name,
    a.build_number,
    a.metric_name,
    a.detector_name,
    a.timestamp,
    a.value,
    a.score,
    a.threshold,
    a.is_anomaly,
    b.status,
    b.triggered_by,
    b.build_start_time,
    b.build_end_time,
    b.building_time_seconds,
    b.blocked_time_seconds,
    b.buildable_time_seconds,
    b.waiting_time_seconds
FROM anomaly_scores a
LEFT JOIN builds b ON a.pipeline_name = b.pipeline_name 
    AND a.build_number = b.build_number
WHERE a.pipeline_name = $1
    AND a.timestamp >= $2
    AND a.timestamp <= $3
ORDER BY a.timestamp DESC
`

type GetBuildDataForAnomalyParams struct {
	PipelineName string             `json:"pipeline_name"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2  pgtype.Timestamptz `json:"timestamp_2"`
}

type GetBuildDataForAnomalyRow struct {
	ID                   int32              `json:"id"`
	PipelineName         string             `json:"pipeline_name"`
	BuildNumber          pgtype.Int4        `json:"build_number"`
	MetricName           string             `json:"metric_name"`
	DetectorName         string             `json:"detector_name"`
	Timestamp            pgtype.Timestamptz `json:"timestamp"`
	Value                float64            `json:"value"`
	Score                float64            `json:"score"`
	Threshold            float64            `json:"threshold"`
	IsAnomaly            bool               `json:"is_anomaly"`
	Status               pgtype.Text        `json:"status"`
	TriggeredBy          pgtype.Text        `json:"triggered_by"`
	BuildStartTime       pgtype.Timestamptz `json:"build_start_time"`
	BuildEndTime         pgtype.Timestamptz `json:"build_end_time"`
	BuildingTimeSeconds  pgtype.Float8      `json:"building_time_seconds"`
	BlockedTimeSeconds   pgtype.Float8      `json:"blocked_time_seconds"`
	BuildableTimeSeconds pgtype.Float8      `json:"buildable_time_seconds"`
	WaitingTimeSeconds   pgtype.Float8      `json:"waiting_time_seconds"`
}

func (q *Queries) GetBuildDataForAnomaly(ctx context.Context, arg GetBuildDataForAnomalyParams) ([]GetBuildDataForAnomalyRow, error) {
	rows, err := q.db.Query(ctx, getBuildDataForAnomaly, arg.PipelineName, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBuildDataForAnomalyRow
	for rows.Next() {
		var i GetBuildDataForAnomalyRow
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.MetricName,
			&i.DetectorName,
			&i.Timestamp,
			&i.Value,
			&i.Score,
			&i.Threshold,
			&i.IsAnomaly,
			&i.Status,
			&i.TriggeredBy,
			&i.BuildStartTime,
			&i.BuildEndTime,
			&i.BuildingTimeSeconds,
			&i.BlockedTimeSeconds,
			&i.BuildableTimeSeconds,
			&i.WaitingTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAnomalyScores = `-- name: GetLatestAnomalyScores :many
SELECT 
    pipeline_name,
    metric_name,
    detector_name,
    MAX(timestamp) as latest_timestamp,
    COUNT(*) FILTER (WHERE is_anomaly = true) as anomaly_count,
    COUNT(*) as total_count
FROM anomaly_scores
WHERE timestamp >= $1
GROUP BY pipeline_name, metric_name, detector_name
ORDER BY latest_timestamp DESC
`

type GetLatestAnomalyScoresRow struct {
	PipelineName    string      `json:"pipeline_name"`
	MetricName      string      `json:"metric_name"`
	DetectorName    string      `json:"detector_name"`
	LatestTimestamp interface{} `json:"latest_timestamp"`
	AnomalyCount    int64       `json:"anomaly_count"`
	TotalCount      int64       `json:"total_count"`
}

func (q *Queries) GetLatestAnomalyScores(ctx context.Context, timestamp pgtype.Timestamptz) ([]GetLatestAnomalyScoresRow, error) {
	rows, err := q.db.Query(ctx, getLatestAnomalyScores, timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestAnomalyScoresRow
	for rows.Next() {
		var i GetLatestAnomalyScoresRow
		if err := rows.Scan(
			&i.PipelineName,
			&i.MetricName,
			&i.DetectorName,
			&i.LatestTimestamp,
			&i.AnomalyCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentAnomaliesForPipeline = `-- name: GetRecentAnomaliesForPipeline :many
SELECT id, pipeline_name, build_number, metric_name, detector_name, timestamp, value, score, threshold, is_anomaly, created_at
FROM anomaly_scores
WHERE pipeline_name = $1
    AND is_anomaly = true
    AND timestamp >= $2
ORDER BY timestamp DESC
LIMIT $3
`

type GetRecentAnomaliesForPipelineParams struct {
	PipelineName string             `json:"pipeline_name"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
	Limit        int32              `json:"limit"`
}

func (q *Queries) GetRecentAnomaliesForPipeline(ctx context.Context, arg GetRecentAnomaliesForPipelineParams) ([]AnomalyScore, error) {
	rows, err := q.db.Query(ctx, getRecentAnomaliesForPipeline, arg.PipelineName, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnomalyScore
	for rows.Next() {
		var i AnomalyScore
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.MetricName,
			&i.DetectorName,
			&i.Timestamp,
			&i.Value,
			&i.Score,
			&i.Threshold,
			&i.IsAnomaly,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSeriesForAnomaly = `-- name: GetTimeSeriesForAnomaly :many
SELECT 
    timestamp,
    value,
    score,
    is_anomaly
FROM anomaly_scores
WHERE pipeline_name = $1
    AND metric_name = $2
    AND timestamp >= $3
    AND timestamp <= $4
ORDER BY timestamp ASC
`

type GetTimeSeriesForAnomalyParams struct {
	PipelineName string             `json:"pipeline_name"`
	MetricName   string             `json:"metric_name"`
	Timestamp    pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2  pgtype.Timestamptz `json:"timestamp_2"`
}

type GetTimeSeriesForAnomalyRow struct {
	Timestamp pgtype.Timestamptz `json:"timestamp"`
	Value     float64            `json:"value"`
	Score     float64            `json:"score"`
	IsAnomaly bool               `json:"is_anomaly"`
}

func (q *Queries) GetTimeSeriesForAnomaly(ctx context.Context, arg GetTimeSeriesForAnomalyParams) ([]GetTimeSeriesForAnomalyRow, error) {
	rows, err := q.db.Query(ctx, getTimeSeriesForAnomaly,
		arg.PipelineName,
		arg.MetricName,
		arg.Timestamp,
		arg.Timestamp_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeSeriesForAnomalyRow
	for rows.Next() {
		var i GetTimeSeriesForAnomalyRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.Value,
			&i.Score,
			&i.IsAnomaly,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
