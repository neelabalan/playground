// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: builds.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBuild = `-- name: CreateBuild :one
INSERT INTO builds (
    pipeline_name,
    build_number,
    build_start_time,
    build_end_time,
    status,
    building_time_seconds,
    error_log,
    triggered_by,
    blocked_time_seconds,
    buildable_time_seconds,
    waiting_time_seconds
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) ON CONFLICT (pipeline_name, build_number) 
DO UPDATE SET
    build_start_time = EXCLUDED.build_start_time,
    build_end_time = EXCLUDED.build_end_time,
    status = EXCLUDED.status,
    building_time_seconds = EXCLUDED.building_time_seconds,
    error_log = EXCLUDED.error_log,
    triggered_by = EXCLUDED.triggered_by,
    blocked_time_seconds = EXCLUDED.blocked_time_seconds,
    buildable_time_seconds = EXCLUDED.buildable_time_seconds,
    waiting_time_seconds = EXCLUDED.waiting_time_seconds,
    updated_at = NOW()
RETURNING id, pipeline_name, build_number, build_start_time, build_end_time, status, last_updated, error_log, created_at, updated_at, triggered_by, building_time_seconds, blocked_time_seconds, buildable_time_seconds, waiting_time_seconds
`

type CreateBuildParams struct {
	PipelineName         string             `json:"pipeline_name"`
	BuildNumber          int32              `json:"build_number"`
	BuildStartTime       pgtype.Timestamptz `json:"build_start_time"`
	BuildEndTime         pgtype.Timestamptz `json:"build_end_time"`
	Status               string             `json:"status"`
	BuildingTimeSeconds  pgtype.Float8      `json:"building_time_seconds"`
	ErrorLog             pgtype.Text        `json:"error_log"`
	TriggeredBy          pgtype.Text        `json:"triggered_by"`
	BlockedTimeSeconds   pgtype.Float8      `json:"blocked_time_seconds"`
	BuildableTimeSeconds pgtype.Float8      `json:"buildable_time_seconds"`
	WaitingTimeSeconds   pgtype.Float8      `json:"waiting_time_seconds"`
}

func (q *Queries) CreateBuild(ctx context.Context, arg CreateBuildParams) (Build, error) {
	row := q.db.QueryRow(ctx, createBuild,
		arg.PipelineName,
		arg.BuildNumber,
		arg.BuildStartTime,
		arg.BuildEndTime,
		arg.Status,
		arg.BuildingTimeSeconds,
		arg.ErrorLog,
		arg.TriggeredBy,
		arg.BlockedTimeSeconds,
		arg.BuildableTimeSeconds,
		arg.WaitingTimeSeconds,
	)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.PipelineName,
		&i.BuildNumber,
		&i.BuildStartTime,
		&i.BuildEndTime,
		&i.Status,
		&i.LastUpdated,
		&i.ErrorLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TriggeredBy,
		&i.BuildingTimeSeconds,
		&i.BlockedTimeSeconds,
		&i.BuildableTimeSeconds,
		&i.WaitingTimeSeconds,
	)
	return i, err
}

const createBuildQueueItem = `-- name: CreateBuildQueueItem :one
INSERT INTO build_queue (
    job_path,
    build_number,
    last_attempt_at,
    error_message,
    collection_time,
    collection_status
) VALUES (
    $1, $2, $3, $4, $5, $6
) ON CONFLICT (job_path, build_number) 
DO UPDATE SET
    last_attempt_at = EXCLUDED.last_attempt_at,
    collection_time = EXCLUDED.collection_time,
    collection_status = EXCLUDED.collection_status,
    updated_at = NOW()
RETURNING id, job_path, build_number, last_attempt_at, error_message, collection_time, collection_status, created_at, updated_at
`

type CreateBuildQueueItemParams struct {
	JobPath          string             `json:"job_path"`
	BuildNumber      int32              `json:"build_number"`
	LastAttemptAt    pgtype.Timestamptz `json:"last_attempt_at"`
	ErrorMessage     pgtype.Text        `json:"error_message"`
	CollectionTime   pgtype.Timestamptz `json:"collection_time"`
	CollectionStatus string             `json:"collection_status"`
}

func (q *Queries) CreateBuildQueueItem(ctx context.Context, arg CreateBuildQueueItemParams) (BuildQueue, error) {
	row := q.db.QueryRow(ctx, createBuildQueueItem,
		arg.JobPath,
		arg.BuildNumber,
		arg.LastAttemptAt,
		arg.ErrorMessage,
		arg.CollectionTime,
		arg.CollectionStatus,
	)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.JobPath,
		&i.BuildNumber,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.CollectionTime,
		&i.CollectionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBuild = `-- name: DeleteBuild :exec
DELETE FROM builds WHERE id = $1
`

func (q *Queries) DeleteBuild(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBuild, id)
	return err
}

const deleteQueueItem = `-- name: DeleteQueueItem :exec
DELETE FROM build_queue WHERE id = $1
`

func (q *Queries) DeleteQueueItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteQueueItem, id)
	return err
}

const getBuildByID = `-- name: GetBuildByID :one
SELECT id, pipeline_name, build_number, build_start_time, build_end_time, status, last_updated, error_log, created_at, updated_at, triggered_by, building_time_seconds, blocked_time_seconds, buildable_time_seconds, waiting_time_seconds FROM builds WHERE id = $1
`

func (q *Queries) GetBuildByID(ctx context.Context, id int32) (Build, error) {
	row := q.db.QueryRow(ctx, getBuildByID, id)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.PipelineName,
		&i.BuildNumber,
		&i.BuildStartTime,
		&i.BuildEndTime,
		&i.Status,
		&i.LastUpdated,
		&i.ErrorLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TriggeredBy,
		&i.BuildingTimeSeconds,
		&i.BlockedTimeSeconds,
		&i.BuildableTimeSeconds,
		&i.WaitingTimeSeconds,
	)
	return i, err
}

const getBuildsByPipeline = `-- name: GetBuildsByPipeline :many
SELECT id, pipeline_name, build_number, build_start_time, build_end_time, status, last_updated, error_log, created_at, updated_at, triggered_by, building_time_seconds, blocked_time_seconds, buildable_time_seconds, waiting_time_seconds FROM builds 
WHERE pipeline_name = $1 
ORDER BY build_number DESC 
LIMIT $2
`

type GetBuildsByPipelineParams struct {
	PipelineName string `json:"pipeline_name"`
	Limit        int32  `json:"limit"`
}

func (q *Queries) GetBuildsByPipeline(ctx context.Context, arg GetBuildsByPipelineParams) ([]Build, error) {
	rows, err := q.db.Query(ctx, getBuildsByPipeline, arg.PipelineName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Build
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.BuildStartTime,
			&i.BuildEndTime,
			&i.Status,
			&i.LastUpdated,
			&i.ErrorLog,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TriggeredBy,
			&i.BuildingTimeSeconds,
			&i.BlockedTimeSeconds,
			&i.BuildableTimeSeconds,
			&i.WaitingTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildsByPipelineAndStatus = `-- name: GetBuildsByPipelineAndStatus :many
SELECT id, pipeline_name, build_number, build_start_time, build_end_time, status, last_updated, error_log, created_at, updated_at, triggered_by, building_time_seconds, blocked_time_seconds, buildable_time_seconds, waiting_time_seconds FROM builds 
WHERE pipeline_name = $1 AND status = $2 
ORDER BY build_number DESC 
LIMIT $3
`

type GetBuildsByPipelineAndStatusParams struct {
	PipelineName string `json:"pipeline_name"`
	Status       string `json:"status"`
	Limit        int32  `json:"limit"`
}

func (q *Queries) GetBuildsByPipelineAndStatus(ctx context.Context, arg GetBuildsByPipelineAndStatusParams) ([]Build, error) {
	rows, err := q.db.Query(ctx, getBuildsByPipelineAndStatus, arg.PipelineName, arg.Status, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Build
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.BuildStartTime,
			&i.BuildEndTime,
			&i.Status,
			&i.LastUpdated,
			&i.ErrorLog,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TriggeredBy,
			&i.BuildingTimeSeconds,
			&i.BlockedTimeSeconds,
			&i.BuildableTimeSeconds,
			&i.WaitingTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBuildsInDateRange = `-- name: GetBuildsInDateRange :many
SELECT id, pipeline_name, build_number, build_start_time, build_end_time, status, last_updated, error_log, created_at, updated_at, triggered_by, building_time_seconds, blocked_time_seconds, buildable_time_seconds, waiting_time_seconds FROM builds 
WHERE build_start_time >= $1 AND build_start_time <= $2 
ORDER BY build_start_time DESC
`

type GetBuildsInDateRangeParams struct {
	BuildStartTime   pgtype.Timestamptz `json:"build_start_time"`
	BuildStartTime_2 pgtype.Timestamptz `json:"build_start_time_2"`
}

func (q *Queries) GetBuildsInDateRange(ctx context.Context, arg GetBuildsInDateRangeParams) ([]Build, error) {
	rows, err := q.db.Query(ctx, getBuildsInDateRange, arg.BuildStartTime, arg.BuildStartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Build
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.BuildStartTime,
			&i.BuildEndTime,
			&i.Status,
			&i.LastUpdated,
			&i.ErrorLog,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TriggeredBy,
			&i.BuildingTimeSeconds,
			&i.BlockedTimeSeconds,
			&i.BuildableTimeSeconds,
			&i.WaitingTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestBuilds = `-- name: GetLatestBuilds :many
SELECT id, pipeline_name, build_number, build_start_time, build_end_time, status, last_updated, error_log, created_at, updated_at, triggered_by, building_time_seconds, blocked_time_seconds, buildable_time_seconds, waiting_time_seconds FROM builds 
ORDER BY build_start_time DESC 
LIMIT $1
`

func (q *Queries) GetLatestBuilds(ctx context.Context, limit int32) ([]Build, error) {
	rows, err := q.db.Query(ctx, getLatestBuilds, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Build
	for rows.Next() {
		var i Build
		if err := rows.Scan(
			&i.ID,
			&i.PipelineName,
			&i.BuildNumber,
			&i.BuildStartTime,
			&i.BuildEndTime,
			&i.Status,
			&i.LastUpdated,
			&i.ErrorLog,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TriggeredBy,
			&i.BuildingTimeSeconds,
			&i.BlockedTimeSeconds,
			&i.BuildableTimeSeconds,
			&i.WaitingTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingQueueItems = `-- name: GetPendingQueueItems :many
SELECT id, job_path, build_number, last_attempt_at, error_message, collection_time, collection_status, created_at, updated_at FROM build_queue 
WHERE collection_status = 'pending' 
ORDER BY collection_time ASC
`

func (q *Queries) GetPendingQueueItems(ctx context.Context) ([]BuildQueue, error) {
	rows, err := q.db.Query(ctx, getPendingQueueItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BuildQueue
	for rows.Next() {
		var i BuildQueue
		if err := rows.Scan(
			&i.ID,
			&i.JobPath,
			&i.BuildNumber,
			&i.LastAttemptAt,
			&i.ErrorMessage,
			&i.CollectionTime,
			&i.CollectionStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueueItemByJobAndBuild = `-- name: GetQueueItemByJobAndBuild :one
SELECT id, job_path, build_number, last_attempt_at, error_message, collection_time, collection_status, created_at, updated_at FROM build_queue 
WHERE job_path = $1 AND build_number = $2
`

type GetQueueItemByJobAndBuildParams struct {
	JobPath     string `json:"job_path"`
	BuildNumber int32  `json:"build_number"`
}

func (q *Queries) GetQueueItemByJobAndBuild(ctx context.Context, arg GetQueueItemByJobAndBuildParams) (BuildQueue, error) {
	row := q.db.QueryRow(ctx, getQueueItemByJobAndBuild, arg.JobPath, arg.BuildNumber)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.JobPath,
		&i.BuildNumber,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.CollectionTime,
		&i.CollectionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTimeSeriesForPipeline = `-- name: GetTimeSeriesForPipeline :many
SELECT 
    build_start_time as timestamp,
    building_time_seconds,
    blocked_time_seconds,
    buildable_time_seconds,
    waiting_time_seconds
FROM builds 
WHERE pipeline_name = $1 
AND build_start_time >= $2 
AND status = 'success'
ORDER BY build_start_time ASC
`

type GetTimeSeriesForPipelineParams struct {
	PipelineName   string             `json:"pipeline_name"`
	BuildStartTime pgtype.Timestamptz `json:"build_start_time"`
}

type GetTimeSeriesForPipelineRow struct {
	Timestamp            pgtype.Timestamptz `json:"timestamp"`
	BuildingTimeSeconds  pgtype.Float8      `json:"building_time_seconds"`
	BlockedTimeSeconds   pgtype.Float8      `json:"blocked_time_seconds"`
	BuildableTimeSeconds pgtype.Float8      `json:"buildable_time_seconds"`
	WaitingTimeSeconds   pgtype.Float8      `json:"waiting_time_seconds"`
}

func (q *Queries) GetTimeSeriesForPipeline(ctx context.Context, arg GetTimeSeriesForPipelineParams) ([]GetTimeSeriesForPipelineRow, error) {
	rows, err := q.db.Query(ctx, getTimeSeriesForPipeline, arg.PipelineName, arg.BuildStartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTimeSeriesForPipelineRow
	for rows.Next() {
		var i GetTimeSeriesForPipelineRow
		if err := rows.Scan(
			&i.Timestamp,
			&i.BuildingTimeSeconds,
			&i.BlockedTimeSeconds,
			&i.BuildableTimeSeconds,
			&i.WaitingTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBuildStatus = `-- name: UpdateBuildStatus :one
UPDATE builds 
SET status = $2, updated_at = NOW() 
WHERE id = $1 
RETURNING id, pipeline_name, build_number, build_start_time, build_end_time, status, last_updated, error_log, created_at, updated_at, triggered_by, building_time_seconds, blocked_time_seconds, buildable_time_seconds, waiting_time_seconds
`

type UpdateBuildStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateBuildStatus(ctx context.Context, arg UpdateBuildStatusParams) (Build, error) {
	row := q.db.QueryRow(ctx, updateBuildStatus, arg.ID, arg.Status)
	var i Build
	err := row.Scan(
		&i.ID,
		&i.PipelineName,
		&i.BuildNumber,
		&i.BuildStartTime,
		&i.BuildEndTime,
		&i.Status,
		&i.LastUpdated,
		&i.ErrorLog,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TriggeredBy,
		&i.BuildingTimeSeconds,
		&i.BlockedTimeSeconds,
		&i.BuildableTimeSeconds,
		&i.WaitingTimeSeconds,
	)
	return i, err
}

const updateQueueItemStatus = `-- name: UpdateQueueItemStatus :one
UPDATE build_queue 
SET collection_status = $2, updated_at = NOW() 
WHERE id = $1 
RETURNING id, job_path, build_number, last_attempt_at, error_message, collection_time, collection_status, created_at, updated_at
`

type UpdateQueueItemStatusParams struct {
	ID               int32  `json:"id"`
	CollectionStatus string `json:"collection_status"`
}

func (q *Queries) UpdateQueueItemStatus(ctx context.Context, arg UpdateQueueItemStatusParams) (BuildQueue, error) {
	row := q.db.QueryRow(ctx, updateQueueItemStatus, arg.ID, arg.CollectionStatus)
	var i BuildQueue
	err := row.Scan(
		&i.ID,
		&i.JobPath,
		&i.BuildNumber,
		&i.LastAttemptAt,
		&i.ErrorMessage,
		&i.CollectionTime,
		&i.CollectionStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
